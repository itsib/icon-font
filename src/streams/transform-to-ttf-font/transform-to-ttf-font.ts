import { Transform, TransformCallback } from 'node:stream';
import { SVGPathData } from 'svg-pathdata';
import { Buffer } from 'node:buffer';
import { BufferWithMeta, SymbolMeta } from '../../types/types.ts';
import { Glyph } from '../../entities/glyph.ts';
import { Font } from '../../entities/font.ts';
import { svgPathToContour } from '../../svg-helpers/svg-path-to-contour.ts';
import { createPostTable } from './tables/post.ts';
import { createNameTable } from './tables/name.ts';
import { createGlyfTable } from './tables/glyf.ts';
import { createLocaTable } from './tables/loca.ts';
import { createCMapTable } from './tables/cmap.ts';
import { createHtmxTable } from './tables/hmtx.ts';
import { createGSUBTable } from './tables/gsub.ts';
import { createOS2Table } from './tables/os2.ts';
import { createMaxpTable } from './tables/maxp.ts';
import { createHeadTable } from './tables/head.ts';
import { createHHeadTable } from './tables/hhea.ts';
import { slugify } from '../../utils/slugify.ts';
import { BufferByte } from '../../entities/buffer-byte.ts';
import { tableIdentifier } from '../../utils/string-to-bytes.ts';
import { TTFTable } from '../../types';
import { interpolate, removeClosingReturnPoints, roundPoints, simplify, toRelative } from '../../utils/contour.ts';

export class TransformToTTFFont extends Transform {

  private readonly _fontName: string;

  private readonly _metadata?: string;

  private _size: number = 0;

  private _isInitialized = false;

  private _glyphs: Glyph[] = [];

  private _glyphsByCode: { [codePoint: number]: Glyph } = {};

  private static _TABLES: TTFTable[] = [
    { innerName: 'GSUB', order: 4, create: createGSUBTable },
    { innerName: 'OS/2', order: 4, create: createOS2Table },
    { innerName: 'cmap', order: 6, create: createCMapTable },
    { innerName: 'glyf', order: 8, create: createGlyfTable },
    { innerName: 'head', order: 2, create: createHeadTable },
    { innerName: 'hhea', order: 1, create: createHHeadTable },
    { innerName: 'hmtx', order: 5, create: createHtmxTable },
    { innerName: 'loca', order: 7, create: createLocaTable },
    { innerName: 'maxp', order: 3, create: createMaxpTable },
    { innerName: 'name', order: 9, create: createNameTable },
    { innerName: 'post', order: 10, create: createPostTable }
  ];

  private static _VERSION = 0x10000;

  private static _CHECKSUM_ADJUSTMENT = 0xB1B0AFBA;

  constructor(fontName: string, metadata?: string) {
    super({ objectMode: true });

    this._fontName = fontName;
    this._metadata = metadata;
  }

  _init(chunk: BufferWithMeta<SymbolMeta>) {
    if (this._isInitialized) return;
    this._isInitialized = true;

    this._size = Math.max(chunk.metadata.width, chunk.metadata.height);

    const glyph = new Glyph();
    glyph.id = 0;
    glyph.name = "";
    glyph.character = "";
    glyph.unicode = [];
    glyph.ligatureCodes = [];
    glyph.codes = [];
    glyph.width = 0;
    glyph.height = this._size;
    glyph.contours = [];
    glyph.d = "";

    this._glyphs.push(glyph);
  }

  _transform(chunk: BufferWithMeta<SymbolMeta>, _encoding: BufferEncoding, callback: TransformCallback) {
    this._init(chunk);
    const pathData = new SVGPathData(chunk.toString())
      .toAbs()
      .aToC()
      .normalizeST();

    const glyphSize = Math.max(chunk.metadata.width, chunk.metadata.height);
    const accuracy = (glyphSize > 500) ? 0.3 : glyphSize * 0.0006;
    let contours = svgPathToContour(pathData, accuracy);
    contours = simplify(contours, 0.3);
    contours = simplify(contours, 0.3);
    contours = interpolate(contours, 1.1);
    contours = roundPoints(contours);
    contours = removeClosingReturnPoints(contours);
    contours = toRelative(contours);

    const glyph = new Glyph();
    glyph.id = this._glyphs.length;
    glyph.name = chunk.metadata.name;
    glyph.character = String.fromCharCode(chunk.metadata.codepoint);
    glyph.unicode = [];
    glyph.ligatureCodes = [];
    glyph.codes = [chunk.metadata.codepoint];
    glyph.width = chunk.metadata.width;
    glyph.height = chunk.metadata.height;
    glyph.contours = contours;

    this._glyphs.push(glyph);
    this._glyphsByCode[chunk.metadata.codepoint] = glyph;

    callback(null, null);
  }

  _flush(callback: TransformCallback): void {
    const creation = new Date();
    const slug = slugify(this._fontName);

    const font = new Font();
    font.id = slug;
    font.familyName = this._fontName;
    font.copyright = this._metadata || '';
    font.description = 'Generated by svg2ttf from Fontello project.';
    font.url = 'http://fontello.com';
    font.subfamilyName = 'Regular';
    font.stretch = 'normal';
    font.sfntNames = [
      { id: 2, value: 'Regular' },
      { id: 4, value: slug },
      { id: 5, value: 'Version 1.0' },
      { id: 6, value: slug }
    ];
    font.createdDate = creation;
    font.modifiedDate = creation;
    font.unitsPerEm = this._size;
    font.horizOriginX = 0;
    font.horizOriginY = 0;
    font.vertOriginX = 0;
    font.vertOriginY = 0;
    font.width = this._size;
    font.height = this._size;
    font.ascent = -this._size;
    font.weightClass = 400;
    font.capHeight = 0;
    font.xHeight = 0;
    font.glyphs = this._glyphs;
    font.codePoints = this._glyphsByCode;
    font.ligatures = [];

    const headerSize = 12 + (16 * TransformToTTFFont._TABLES.length);
    let bufSize = headerSize;

    TransformToTTFFont._TABLES.forEach(table => {
      table.buffer = table.create(font);
      table.length = table.buffer.length;
      table.corLength = table.length + (4 - table.length % 4) % 4;
      table.checkSum = this._calcChecksum(table.buffer);
      bufSize += table.corLength;
    });

    let offset = headerSize;

    TransformToTTFFont._TABLES.forEach(table => {
      table.offset = offset;
      offset += table.corLength!;
    });

    const buf = new BufferByte(bufSize);

    const entrySelector = Math.floor(Math.log(TransformToTTFFont._TABLES.length) / Math.LN2);
    const searchRange = Math.pow(2, entrySelector) * 16;
    const rangeShift = TransformToTTFFont._TABLES.length * 16 - searchRange;

    buf.writeUint32(TransformToTTFFont._VERSION);
    buf.writeUint16(TransformToTTFFont._TABLES.length);
    buf.writeUint16(searchRange);
    buf.writeUint16(entrySelector);
    buf.writeUint16(rangeShift);

    TransformToTTFFont._TABLES.forEach((table, index) => {
      buf.writeUint32(tableIdentifier(table.innerName));
      buf.writeUint32(table.checkSum!);
      buf.writeUint32(table.offset!);
      buf.writeUint32(table.length!);
    });

    let headOffset = 0;

    // const tables2 = TABLES.sort((a, b) => b.order - a.order);
    TransformToTTFFont._TABLES.forEach(table => {
      if (table.innerName === 'head') {
        headOffset = buf.tell();
      }
      buf.writeBytes(table.buffer!.buffer);
      for (let i = table.length!; i < table.corLength!; i++) {
        buf.writeUint8(0);
      }
    });


    buf.setUint32(headOffset + 8, this._ulong(TransformToTTFFont._CHECKSUM_ADJUSTMENT - this._calcChecksum(buf)))

    callback(null, Buffer.from(buf.buffer));
  }

  private _calcChecksum(buf: BufferByte): number {
    let sum = 0;
    const nlongs = Math.floor(buf.length / 4);

    for (let i = 0; i < nlongs; ++i) {
      const t = buf.getUint32(i * 4);
      sum = this._ulong(sum + t);
    }

    const leftBytes = buf.length - nlongs * 4;

    if (leftBytes > 0) {
      let leftRes = 0;

      for (let i = 0; i < 4; i++) {
        leftRes = (leftRes << 8) + ((i < leftBytes) ? buf.getUint8(nlongs * 4 + i) : 0);
      }
      sum = this._ulong(sum + leftRes);
    }
    return sum;
  }

  private _ulong(t: number): number {
    t &= 0xffffffff;
    if (t < 0) {
      t += 0x100000000;
    }
    return t;
  }
}