import { SVGPathData } from 'svg-pathdata';
import * as sfnt from './lib/sfnt.ts';
import { ucs2encode } from './lib/ucs2.ts';
import { generateTTF } from './lib/ttf.ts';
import ByteBuffer from 'microbuffer';
import { load } from './lib/svg.ts';
import { svgPathToContour } from '../svg-helpers/svg-path-to-contour.ts';

const VERSION_RE = /^(Version )?(\d+[.]\d+)$/i;

interface Options {
  id?: string;
  familyname?: string;
  copyright?: string;
  description?: string;
  url?: string;
  subfamilyname?: string;
  fullname?: string;
  version?: string;
  ts?: string;
}

export function svg2ttf(svgString: string, options?: Options): ByteBuffer {
  const font = new sfnt.Font();
  const svgFont = load(svgString);

  options = options || {};

  font.id = options.id || svgFont.id;
  font.familyName = options.familyname || svgFont.familyName || svgFont.id;
  font.copyright = options.copyright || svgFont.metadata || '';
  font.description = options.description || 'Generated by svg2ttf from Fontello project.';
  font.url = options.url || 'http://fontello.com';
  font.sfntNames.push({ id: 2, value: options.subfamilyname || svgFont.subfamilyName || 'Regular' });
  font.sfntNames.push({ id: 4, value: options.fullname || svgFont.id });

  let versionString = options.version || 'Version 1.0';

  if (typeof versionString !== 'string') {
    throw new Error('svg2ttf: version option should be a string');
  }
  if (!VERSION_RE.test(versionString)) {
    throw new Error('svg2ttf: invalid option, version - "' + options.version + '"');
  }

  versionString = 'Version ' + versionString.match(VERSION_RE)![2];
  font.sfntNames.push({ id: 5, value: versionString });
  font.sfntNames.push({ id: 6, value: (options.fullname || svgFont.id).replace(/[\s\(\)\[\]<>%\/]/g, '').slice(0, 62) });

  if (typeof options.ts !== 'undefined') {
    font.createdDate = font.modifiedDate = new Date(parseInt(options.ts, 10) * 1000);
  }

  font.unitsPerEm = svgFont.unitsPerEm || 1000;
  font.horizOriginX = svgFont.horizOriginX || 0;
  font.horizOriginY = svgFont.horizOriginY || 0;
  font.vertOriginX = svgFont.vertOriginX || 0;
  font.vertOriginY = svgFont.vertOriginY || 0;
  font.width = svgFont.width || svgFont.unitsPerEm;
  font.height = svgFont.height || svgFont.unitsPerEm;
  font.descent = !isNaN(svgFont.descent) ? svgFont.descent : -font.vertOriginY;
  font.ascent = svgFont.ascent || (font.unitsPerEm - font.vertOriginY);
  font.capHeight = svgFont.capHeight || 0;
  font.xHeight = svgFont.xHeight || 0;

  if (typeof svgFont.weightClass !== 'undefined') {
    const wght = parseInt(svgFont.weightClass as string, 10);

    if (!isNaN(wght)) {
      font.weightClass = wght
    }
    else {
      if (svgFont.weightClass === 'normal') font.weightClass = 400;
      if (svgFont.weightClass === 'bold') font.weightClass = 700;
    }
  }

  if (svgFont.underlinePosition != null) {
    font.underlinePosition = svgFont.underlinePosition;
  }
  if (svgFont.underlineThickness != null) {
    font.underlineThickness = svgFont.underlineThickness;
  }

  const glyphs: sfnt.Glyph[] = font.glyphs;
  const codePoints: { [key: number]: sfnt.Glyph } = font.codePoints;
  const ligatures: { ligature: string; unicode: number[]; glyph: sfnt.Glyph }[] = font.ligatures;

  function addCodePoint(codePoint: number, glyph: sfnt.Glyph): boolean {
    if (codePoints[codePoint]) {
      return false;
    }
    codePoints[codePoint] = glyph;
    return true;
  }

  svgFont.glyphs.forEach(svgGlyph => {
    const glyph = new sfnt.Glyph();

    glyph.name = svgGlyph.name;
    glyph.codes = svgGlyph.ligatureCodes || svgGlyph.unicode;
    glyph.d = svgGlyph.d;
    glyph.height = !isNaN(svgGlyph.height) ? svgGlyph.height : font.height;
    glyph.width = !isNaN(svgGlyph.width) ? svgGlyph.width : font.width;
    glyphs.push(glyph);

    (svgGlyph as any).sfntGlyph = glyph;

    svgGlyph.unicode.forEach(codePoint => {
      addCodePoint(codePoint, glyph);
    });
  });

  let missingGlyph: sfnt.Glyph;

  if (svgFont.missingGlyph) {
    missingGlyph = new sfnt.Glyph();
    missingGlyph.d = svgFont.missingGlyph.d!;
    missingGlyph.height = (!isNaN(svgFont.missingGlyph.height!) ? svgFont.missingGlyph.height : font.height)!;
    missingGlyph.width = (!isNaN(svgFont.missingGlyph.width!) ? svgFont.missingGlyph.width : font.width)!;
  } else {
    missingGlyph = glyphs.find(glyph => glyph.name === '.notdef')!;
  }
  if (!missingGlyph) {
    missingGlyph = new sfnt.Glyph();
  }

  svgFont.ligatures.forEach(svgLigature => {
    const ligature = {
      ligature: svgLigature.ligature,
      unicode: svgLigature.unicode,
      glyph: (svgLigature.glyph as any).sfntGlyph
    };

    ligature.unicode.forEach(charPoint => {
      const glyph = new sfnt.Glyph();
      const added = addCodePoint(charPoint, glyph);

      if (added) {
        glyph.name = ucs2encode([charPoint]);
        glyphs.push(glyph);
      }
    });
    ligatures.push(ligature);
  });

  if (glyphs.indexOf(missingGlyph) !== -1) {
    glyphs.splice(glyphs.indexOf(missingGlyph), 1);
  }
  glyphs.unshift(missingGlyph);

  let nextID = 0;

  glyphs.forEach(glyph => {
    glyph.id = nextID;
    nextID++;
  });

  glyphs.forEach(glyph => {
    const glyphSize = Math.max(glyph.width, glyph.height);
    const accuracy = (glyphSize > 500) ? 0.3 : glyphSize * 0.0006;

    const svgPath = new SVGPathData(glyph.d);
    const sfntContours = svgPathToContour(svgPath, accuracy);

    glyph.contours = sfntContours.map(sfntContour => {
      const contour = new sfnt.Contour();

      contour.points = sfntContour.map(sfntPoint => {
        const point = new sfnt.Point();

        point.x = sfntPoint.x;
        point.y = sfntPoint.y;
        point.onCurve = sfntPoint.onCurve;
        return point;
      });

      return contour;
    });
  });

  return generateTTF(font);
}
